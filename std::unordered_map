//函数签名
//empty(1)
//unordered_map();
//explicit unordered_map(size_type n,
//	const hasher& hf = hasher(),
//	const key_equal& eql = key_equal(),
//	const allocator_type& alloc = allocator_type());
//explicit unordered_map(const allocator_type& alloc);
//unordered_map(size_type n, const allocator_type& alloc);
//unordered_map(size_type n, const hasher& hf, const allocator_type& alloc);
//range(2)
//template <class InputIterator>
//unordered_map(InputIterator first, InputIterator last,
//	size_type n = /* see below */,
//	const hasher& hf = hasher(),
//	const key_equal& eql = key_equal(),
//	const allocator_type& alloc = allocator_type());
//template <class InputIterator>
//unordered_map(InputIterator first, InputIterator last,
//	size_type n, const allocator_type& alloc);
//template <class InputIterator>
//unordered_map(InputIterator first, InputIterator last,
//	size_type n, const hasher& hf, const allocator_type& alloc);
//copy(3)
//unordered_map(const unordered_map& ump);
//unordered_map(const unordered_map& ump, const allocator_type& alloc);
//move(4)
//unordered_map(unordered_map&& ump);
//unordered_map(unordered_map&& ump, const allocator_type& alloc);
//initializer list(5)
//unordered_map(initializer_list<value_type> il,
//	size_type n = /* see below */,
//	const hasher& hf = hasher(),
//	const key_equal& eql = key_equal(),
//	const allocator_type& alloc = allocator_type());
//unordered_map(initializer_list<value_type> il,
//	size_type n, const allocator_type& alloc);
//unordered_map(initializer_list<value_type> il,
//	size_type n, const hasher& hf, const allocator_type& alloc);
//copy(1)
//unordered_map& operator= (const unordered_map& ump);
//move(2)
//unordered_map& operator= (unordered_map&& ump);
//initializer list(3)
//unordered_map& operator= (intitializer_list<value_type> il);
#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;
typedef unordered_map<string, string> stringMap;
stringMap merge(stringMap a, stringMap b)
{
	stringMap tmp(a);
	tmp.insert(b.begin(), b.end());
	return tmp;
}
int main()
{
	stringMap first_sm;										//empty
	stringMap second_sm({ { "a","b" }, { "c","d" } });		//init list
	stringMap third_sm({ {"e","f"},{"g","h"} });
	stringMap fourth_map(second_sm);						//copy
	stringMap fifth_map(merge(second_sm, third_sm));		//move ,因为这里是右值
	stringMap six_map(fifth_map.begin(), fifth_map.end());	//range
	for (auto &x : six_map)
		cout << x.first << " " << x.second << endl;

	first_sm = merge(second_sm, third_sm);					//move
	second_sm = third_sm;									//copy
	return 0;
}
//输出：
//a b
//c d
//e f
//g h

//函数签名
//bool empty() const noexcept;
//size_type size() const noexcept;
//size_type max_size() const noexcept;
#include<iostream>
#include<unordered_map>
using namespace std;
int main()
{
	unordered_map<int, int> first_um = { {1,1},{3,3} ,{2,2} };
	if (!first_um.empty())
		cout << "first_um is not empty." << endl;
	cout << "Size of first_um : " << first_um.size() << endl;
	cout << "Maxsize of first_um : " << first_um.max_size() << endl;
	return 0;
}
//输出：
//first_um is not empty.
//Size of first_um : 3
//Maxsize of first_um : 268435455

//函数签名
//container iterator(1)
//iterator begin() noexcept;
//const_iterator begin() const noexcept;
//bucket iterator(2)
//local_iterator begin(size_type n);
//const_local_iterator begin(size_type n) const;
//container iterator(1)
//iterator end() noexcept;
//const_iterator end() const noexcept;
//bucket iterator(2)
//local_iterator end(size_type n);
//const_local_iterator end(size_type n) const;
//container iterator(1)
//const_iterator cbegin() const noexcept;
//bucket iterator(2)
//const_local_iterator cbegin(size_type n) const;
//container iterator(1)
//const_iterator cend() const noexcept;
//bucket iterator(2)
//const_local_iterator cend(size_type n) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { {"a","a"},{"c","c"},{"e","e"} };
	for (auto it = first_um.begin(); it != first_um.end(); it++)
		cout << it->first << "->" << it->second << endl;
	for (int i = 0; i != first_um.bucket_count(); i++)
	{
		cout << "bucket " << i << " contains :";
		for (auto local_it = first_um.begin(i); local_it != first_um.end(i); local_it++)
			cout << local_it->first << "->" << local_it->second;
		cout << endl;
	}
	for (auto it = first_um.cbegin(); it != first_um.cend(); it++)
		cout << it->first << "->" << it->second << endl;
	return 0;
}
//输出：
//a->a
//c->c
//e->e
//bucket 0 contains :e->e
//bucket 1 contains :
//bucket 2 contains :c->c
//bucket 3 contains :
//bucket 4 contains :a->a
//bucket 5 contains :
//bucket 6 contains :
//bucket 7 contains :
//a->a
//c->c
//e->e

//函数签名
//mapped_type& operator[] (const key_type& k);
//mapped_type& operator[] (key_type&& k);
//mapped_type& at(const key_type& k);
//const mapped_type& at(const key_type& k) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { { "a","a" },{ "c","c" },{ "e","e" } };
	string tmp;
	first_um["a"] = "b";
	first_um["b"] = "a";
	tmp = first_um["z"];
	for (auto x : first_um)
		cout << x.first << "->" << x.second << endl;
	unordered_map<string, int>  second_um = { {"a",1},{"b",2},{"c",3} };
	second_um.at("a") = 2;
	second_um.at("b") += 2;
	second_um.at("c") = second_um.at("a") + 1;
	for (auto x : second_um)
		cout << x.first << "->" << x.second << endl;
	return 0;
}
//输出：
//a->b
//c->c
//e->e
//z->
//b->a
//a->2
//b->4
//c->3

//函数签名
//iterator find(const key_type& k);
//const_iterator find(const key_type& k) const;
//size_type count(const key_type& k) const;
//pair<iterator, iterator>
//equal_range(const key_type& k);
//pair<const_iterator, const_iterator>
//equal_range(const key_type& k) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { { "a","a" },{ "c","c" },{ "e","e" },{"a","b"} };
	auto it = first_um.find("a");
	cout << it->first << "->" << it->second << endl;
	cout << first_um.count("a") << endl;		//因为不允许多键，所以只能返回1或者0

	auto ItPair = first_um.equal_range("c");
	cout << ItPair.first->first << "->" << ItPair.first->second << endl;
	cout << ItPair.second->first << "->" << ItPair.second->second << endl;
	return 0;
}
//输出：
//a->a
//1
//c->c
//e->e

//函数签名
//template <class... Args>
//pair<iterator, bool> emplace(Args&&... args);
//template <class... Args>
//iterator emplace_hint(const_iterator position, Args&&... args);
//(1)
//pair<iterator, bool> insert(const value_type& val);
//(2)
//template <class P>
//pair<iterator, bool> insert(P&& val);
//(3)
//iterator insert(const_iterator hint, const value_type& val);
//(4)
//template <class P>
//iterator insert(const_iterator hint, P&& val);
//(5)
//template <class InputIterator>
//void insert(InputIterator first, InputIterator last);
//(6)
//void insert(initializer_list<value_type> il);
//by position (1)	
//iterator erase(const_iterator position);
//by key(2)
//size_type erase(const key_type& k);
//range(3)
//iterator erase(const_iterator first, const_iterator last);
//void clear() noexcept;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um;
	first_um.emplace("a", "a");
	first_um.emplace("b", "b");
	first_um.emplace("c", "c");
	auto it = first_um.find("b");
	first_um.emplace_hint(it, "e", "e");
	for (auto x : first_um)
		cout << x.first << "->" << x.second << endl;
	pair<unordered_map<string, string>::iterator, bool> itPair = first_um.insert({ "b", "c" });
	if (!itPair.second)
		cout << "The key of \"b\" existed." << endl;
	first_um.erase("b");
	first_um.erase(first_um.begin());
	first_um.emplace("x", "x");
	first_um.emplace("o", "o");
	first_um.emplace("z","z");
	first_um.erase(first_um.find("o"), first_um.end());
	for (auto x : first_um)
		cout << x.first << "->" << x.second << endl;
	first_um.clear();
	unordered_map<string, string> second_um;
	first_um.swap(second_um);
	return 0;
}
//输出：
//a->a
//b->b
//c->c
//e->e
//The key of "b" existed.
//c->c
//e->e
//x->x

//函数签名
//size_type bucket_count() const noexcept;
//size_type max_bucket_count() const noexcept;
//size_type bucket_size(size_type n) const;
//size_type bucket(const key_type& k) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { { "a","a" },{ "c","c" },{ "e","e" } ,{"f","f"},{"o","k"} };
	int cnt = first_um.bucket_count();
	cout << "first_um has " << cnt << "buckets" << endl;
	for (int i = 0; i != cnt; i++)
	{
		cout << "bucket # " << i << "contains:";
		for (auto it = first_um.begin(i); it != first_um.end(i); it++)
			cout << "[" << it->first << ":" << it->second << "] ";
		cout << endl;
	}
	unordered_map<int, int> second_um;
	cout << "max_size = " << second_um.max_size() << endl;
	cout << "max_bucket_count = " << second_um.max_bucket_count() << endl;
	cout << "max_load_factor = " << second_um.max_load_factor() << endl;

	for (int i = 0; i != first_um.bucket_count(); i++)
	{
		cout << "bucket # " << i << " has " << first_um.bucket_size(i) << " element." << endl;
	}

	for (auto x : first_um)
	{
		cout << "Element [" << x.first << ":" << x.second << "]";
		cout << "is in bucket # " << first_um.bucket(x.first) << endl;
	}
	return 0;
}
//输出：
//first_um has 11buckets
//bucket # 0contains:[c:c]
//bucket # 1contains:[e:e]
//bucket # 2contains:
//bucket # 3contains:
//bucket # 4contains:
//bucket # 5contains:
//bucket # 6contains:
//bucket # 7contains:[o:k] [a:a]
//bucket # 8contains:[f:f]
//bucket # 9contains:
//bucket # 10contains:
//max_size = 1152921504606846975
//max_bucket_count = 1152921504606846975
//max_load_factor = 1
//bucket # 0 has 1 element.
//bucket # 1 has 1 element.
//bucket # 2 has 0 element.
//bucket # 3 has 0 element.
//bucket # 4 has 0 element.
//bucket # 5 has 0 element.
//bucket # 6 has 0 element.
//bucket # 7 has 2 element.
//bucket # 8 has 1 element.
//bucket # 9 has 0 element.
//bucket # 10 has 0 element.
//Element[o:k]is in bucket # 7
//Element[a:a]is in bucket # 7
//Element[c:c]is in bucket # 0
//Element[e:e]is in bucket # 1
//Element[f:f]is in bucket # 8
