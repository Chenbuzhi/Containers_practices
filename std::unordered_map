//函数签名
//empty(1)
//unordered_map();
//explicit unordered_map(size_type n,
//	const hasher& hf = hasher(),
//	const key_equal& eql = key_equal(),
//	const allocator_type& alloc = allocator_type());
//explicit unordered_map(const allocator_type& alloc);
//unordered_map(size_type n, const allocator_type& alloc);
//unordered_map(size_type n, const hasher& hf, const allocator_type& alloc);
//range(2)
//template <class InputIterator>
//unordered_map(InputIterator first, InputIterator last,
//	size_type n = /* see below */,
//	const hasher& hf = hasher(),
//	const key_equal& eql = key_equal(),
//	const allocator_type& alloc = allocator_type());
//template <class InputIterator>
//unordered_map(InputIterator first, InputIterator last,
//	size_type n, const allocator_type& alloc);
//template <class InputIterator>
//unordered_map(InputIterator first, InputIterator last,
//	size_type n, const hasher& hf, const allocator_type& alloc);
//copy(3)
//unordered_map(const unordered_map& ump);
//unordered_map(const unordered_map& ump, const allocator_type& alloc);
//move(4)
//unordered_map(unordered_map&& ump);
//unordered_map(unordered_map&& ump, const allocator_type& alloc);
//initializer list(5)
//unordered_map(initializer_list<value_type> il,
//	size_type n = /* see below */,
//	const hasher& hf = hasher(),
//	const key_equal& eql = key_equal(),
//	const allocator_type& alloc = allocator_type());
//unordered_map(initializer_list<value_type> il,
//	size_type n, const allocator_type& alloc);
//unordered_map(initializer_list<value_type> il,
//	size_type n, const hasher& hf, const allocator_type& alloc);
//copy(1)
//unordered_map& operator= (const unordered_map& ump);
//move(2)
//unordered_map& operator= (unordered_map&& ump);
//initializer list(3)
//unordered_map& operator= (intitializer_list<value_type> il);
#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;
typedef unordered_map<string, string> stringMap;
stringMap merge(stringMap a, stringMap b)
{
	stringMap tmp(a);
	tmp.insert(b.begin(), b.end());
	return tmp;
}
int main()
{
	stringMap first_sm;										//empty
	stringMap second_sm({ { "a","b" }, { "c","d" } });		//init list
	stringMap third_sm({ {"e","f"},{"g","h"} });
	stringMap fourth_map(second_sm);						//copy
	stringMap fifth_map(merge(second_sm, third_sm));		//move ,因为这里是右值
	stringMap six_map(fifth_map.begin(), fifth_map.end());	//range
	for (auto &x : six_map)
		cout << x.first << " " << x.second << endl;

	first_sm = merge(second_sm, third_sm);					//move
	second_sm = third_sm;									//copy
	return 0;
}
//输出：
//a b
//c d
//e f
//g h

//函数签名
//bool empty() const noexcept;
//size_type size() const noexcept;
//size_type max_size() const noexcept;
#include<iostream>
#include<unordered_map>
using namespace std;
int main()
{
	unordered_map<int, int> first_um = { {1,1},{3,3} ,{2,2} };
	if (!first_um.empty())
		cout << "first_um is not empty." << endl;
	cout << "Size of first_um : " << first_um.size() << endl;
	cout << "Maxsize of first_um : " << first_um.max_size() << endl;
	return 0;
}
//输出：
//first_um is not empty.
//Size of first_um : 3
//Maxsize of first_um : 268435455

//函数签名
//container iterator(1)
//iterator begin() noexcept;
//const_iterator begin() const noexcept;
//bucket iterator(2)
//local_iterator begin(size_type n);
//const_local_iterator begin(size_type n) const;
//container iterator(1)
//iterator end() noexcept;
//const_iterator end() const noexcept;
//bucket iterator(2)
//local_iterator end(size_type n);
//const_local_iterator end(size_type n) const;
//container iterator(1)
//const_iterator cbegin() const noexcept;
//bucket iterator(2)
//const_local_iterator cbegin(size_type n) const;
//container iterator(1)
//const_iterator cend() const noexcept;
//bucket iterator(2)
//const_local_iterator cend(size_type n) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { {"a","a"},{"c","c"},{"e","e"} };
	for (auto it = first_um.begin(); it != first_um.end(); it++)
		cout << it->first << "->" << it->second << endl;
	for (int i = 0; i != first_um.bucket_count(); i++)
	{
		cout << "bucket " << i << " contains :";
		for (auto local_it = first_um.begin(i); local_it != first_um.end(i); local_it++)
			cout << local_it->first << "->" << local_it->second;
		cout << endl;
	}
	for (auto it = first_um.cbegin(); it != first_um.cend(); it++)
		cout << it->first << "->" << it->second << endl;
	return 0;
}
//输出：
//a->a
//c->c
//e->e
//bucket 0 contains :e->e
//bucket 1 contains :
//bucket 2 contains :c->c
//bucket 3 contains :
//bucket 4 contains :a->a
//bucket 5 contains :
//bucket 6 contains :
//bucket 7 contains :
//a->a
//c->c
//e->e

//函数签名
//mapped_type& operator[] (const key_type& k);
//mapped_type& operator[] (key_type&& k);
//mapped_type& at(const key_type& k);
//const mapped_type& at(const key_type& k) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { { "a","a" },{ "c","c" },{ "e","e" } };
	string tmp;
	first_um["a"] = "b";
	first_um["b"] = "a";
	tmp = first_um["z"];
	for (auto x : first_um)
		cout << x.first << "->" << x.second << endl;
	unordered_map<string, int>  second_um = { {"a",1},{"b",2},{"c",3} };
	second_um.at("a") = 2;
	second_um.at("b") += 2;
	second_um.at("c") = second_um.at("a") + 1;
	for (auto x : second_um)
		cout << x.first << "->" << x.second << endl;
	return 0;
}
//输出：
//a->b
//c->c
//e->e
//z->
//b->a
//a->2
//b->4
//c->3

//函数签名
//iterator find(const key_type& k);
//const_iterator find(const key_type& k) const;
//size_type count(const key_type& k) const;
//pair<iterator, iterator>
//equal_range(const key_type& k);
//pair<const_iterator, const_iterator>
//equal_range(const key_type& k) const;
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int main()
{
	unordered_map<string, string> first_um = { { "a","a" },{ "c","c" },{ "e","e" },{"a","b"} };
	auto it = first_um.find("a");
	cout << it->first << "->" << it->second << endl;
	cout << first_um.count("a") << endl;		//因为不允许多键，所以只能返回1或者0

	auto ItPair = first_um.equal_range("c");
	cout << ItPair.first->first << "->" << ItPair.first->second << endl;
	cout << ItPair.second->first << "->" << ItPair.second->second << endl;
	return 0;
}
//输出：
//a->a
//1
//c->c
//e->e
